#!/usr/bin/env python
# Analyzes output generated by specularity scan
from __future__ import print_function
import numpy as np
import argparse
import pandas as pd
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy.optimize import curve_fit
import sys
import os

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt

def fit(t, b, c):
    # Function for fitting <Sx>
    return np.exp(-(t - c) / b )

# Guess for parameters to fit
guess = [100, 5]

def main():
    ###### arguments #######
    folder = '/N/dc2/scratch/dkwong/'
    joblist = 'joblist.out'
    tRange = [2,99]  # sec
    tStep  = 0.001    # sec
    ########################

    print('Reading ', joblist)
    startRun, endRun, spec = np.genfromtxt(joblist, unpack=True, comments='#')

    t2Estimate = []
    t2Error = []

    if (folder[-1] != '/'):
        folder = folder + '/'

    for start, end, s in zip(startRun, endRun, spec):
        outputFileName = 'run' + str(int(start)) + '-' + str(int(end)) + '_d=' + str(s) + '.txt'

        if os.path.isfile(outputFileName):
            print('Reading from ', outputFileName)
            t2Times, sxAv, syAv = np.genfromtxt(outputFileName, unpack=True)
        else:
            print('\nReading run files where d=',s)
            runNum = np.arange(int(start),int(end)+1)
            t2Times = np.arange(tRange[0],tRange[1] + tStep, tStep)
            simTotal = 0
            missedRuns = []
            sxT2 = np.zeros(len(t2Times))
            syT2 = np.zeros(len(t2Times))

            for i in runNum:
                runName = folder + str(i).zfill(12) + 'neutronspin.out'
                print(i,'...', end='')
                sys.stdout.flush()      # Yes, I know print has a flush=True option. Doesn't work in python2
                try:
                    df = pd.read_csv(runName, delim_whitespace=True, usecols=[1, 2, 6, 7]).drop_duplicates(subset='t', keep='first')
                    # Columns are titled 'particle, t, Sx, Sy'
                except:
                    missedRuns.append(i)
                    continue

                simTotal += df['particle'].iloc[-1]

                for particleNum in np.arange(1, df["particle"].iloc[-1] + 1 ):
                    # Skip canceled runs
                    if t2Times[-2] > df.query("particle == @particleNum")["t"].iloc[-1]:
                        simTotal -= 1
                        continue
                    # Interpolate
                    try:
                        interpX = InterpolatedUnivariateSpline(df.query("particle == @particleNum")["t"], df.query("particle == @particleNum")["Sx"])
                        interpY = InterpolatedUnivariateSpline(df.query("particle == @particleNum")["t"], df.query("particle == @particleNum")["Sy"])
                        # sxT2.append( interpX(t2Times) )
                        # syT2.append( interpY(t2Times) )
                        sxT2 = sxT2 + np.array(interpX(t2Times))
                        syT2 = syT2 + np.array(interpY(t2Times))
                    except:
                        simTotal -= 1
                # ENDFOR

            print('okay!')
            print('Error reading run numbers-- ', missedRuns)
            print('Number of neutrons simulated: ', simTotal)

            sxAv = sxT2/simTotal
            syAv = syT2/simTotal

            print('Saving t2Times, <Sx>, <Sy> to ', outputFileName)
            np.savetxt(outputFileName, np.c_[t2Times, sxAv, syAv])
            #ENDFOR

        # Fit function for T2
        print('Fitting T2...')
        decayCurve = np.sqrt( np.square(sxAv) + np.square(syAv) )

        popt, pcov = curve_fit(fit, t2Times, decayCurve, p0=guess)
        print('Fitted parameters')
        print(popt)
        print('+/- [',np.sqrt(pcov[0][0]),', ', np.sqrt(pcov[1][1]), ']')
        t2Estimate.append(popt[0])
        t2Error.append(np.sqrt(pcov[0][0]))
    #ENDFOR

    t2filename = 't2_run' + str(int(startRun[0])) + '-' + str(int(endRun[-1]))
    print('\n\nDONE... Saving t2 estimates to ', t2filename + '.txt')
    np.savetxt(t2filename + '.txt', np.c_[spec, t2Estimate, t2Error])

    print('Now saving a plot')
    fig = plt.figure()
    plt.plot(spec, t2Estimate, marker='.')
    plt.grid(True)
    plt.xlabel('Diffuse Reflection Prob')
    plt.ylabel('T2 [sec]')

    plt.savefig(t2filename + '.png')
    print('Done')



    return

if ( __name__ == '__main__' ):
    main()
